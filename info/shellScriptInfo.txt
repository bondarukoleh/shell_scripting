Script
Command line programm that contains a series of commands.
Shell access the interpreter and executes commands in script one by another.
Script either in PATH variable (you can execute it from everywhere) or you can execute in with "./path_to_script/scr.sh"

# (sharp) ! (bang) (shebang) /usr/bin/env bash (path to interpreter for commands listened in file, depends on OS)
There a few interpreters /bin/csh, ksh, zsh. Or even #!/usr/bin/pyton #!/usr/bin/node

If you do not adding shebang - that script will be executed by default shell in OS, witch can cost problems,
maybe your shell by default is ok, but you don't know nothing about other guys.

VARIABLES
VARIABLE_NAME="value" - no spaces, by convention variable name in upper case. Case sencetive.
Without quotes only text without spaces, can contain "_" and digits, but not start from digits.
To use variable put "My $VAR_NAME string" before name, ore "My ${VAR_NAME} string"

We can store commands output in variables.
PING_GOOGLE=$(ping -c 1 google.com)
tells to run ping and write it's output to variable

CONDITIONS
We can create conditions:
if [ condition_to_test && condition_to_test ]  
then
  command1
  command2
elseif [ next_condition_to_test || next_condition_to_test ]
then
  command3
  command4
else
  command5
  command6
fi (if spelled backwards)

Note: we can use AND vs OR in our commands, like $>cp text.txt /tmp/inner || cp text.txt /tmp
if /tmp/inner folder doesn't exists - it will copy to /tmp.
 (sic!) - Command after AND will be executed only if previous returned 0;
 (sic!) - Command after OR will be executed only if previous returned 1;
Also we can use condition statements in terminal $>[ -d ./dor_path_to_check ] && do_something (if dir exists - action)
But aware that "success" || "not_runned" && "runned" - if success - that it passes next OR and run next AND.

If we meet conditions - condition return true, and command exits with status 0, if not - false - 1 status.

Conditions:
-d $FILE - FILE is directory? 
-e $FILE - FILE is existing file? 
-f $FILE - FILE is regular file? 
-r $FILE - FILE is readable file by user? 
-s $FILE - FILE is not empty file? 
-w $FILE - FILE is writable file by user? 
-x $FILE - FILE is executable file by user? 

-z $STRING - STRING is empty?
-n $STRING - STRING is not empty?
$STRING1 = $STRING2 - are strings equal?
$STRING1 != $STRING2 - are strings not equal?

$ARG1 -eq $ARG2 - are args equal?
$ARG1 -ne $ARG2 - are args not equal?
$ARG1 -lt $ARG2 - is arg1 is less than arg2?
$ARG1 -le $ARG2 - is arg1 is less than or equal arg2?
$ARG1 -gt $ARG2 - is arg1 is greater than arg2?
$ARG1 -ge $ARG2 - is arg1 is greater than or equal arg2?

Boolean Operator     Numeric     String  
===================  =======     ======  
Equals                 -eq        =      
Not Equals             -ne        !=     
Greater Than           -gt        >      
Less Than              -lt        <      
Greater or Equals      -ge        >=     
Less Than or Equals    -le        <= 


FOR LOOP
for VAR_NAME in ARRAY
do
  command1
  command2
  [ condition_to_exit ] && break
  [ condition_to_continue ] && continue
done


PASSED ARGUMENTS
./script.sh arg1 arg2=value
$0:"script.sh" (same as ${0})
$1:"arg1"
$2:"arg2=value"
$@:"arg1 arg2=value"

So 0 argument - is useless in most cases from my side, it's pointing on script that was passed to bash

shift - is used to shift position of parameters to the left, means delete first argument.

STDIN
We can read from stdin
read -p "Text of prompt (hint) what you are expecting user should input" VARIABLE_TO_STORE_USERS_INPUT

read -p "Please enter your name: " USER_NAME
echo "You're name is $USER_NAME"


EXIT STATUS
Every command return an exit status, integer range 0 to 255
Exit code != 0 is stand for some error.

$? - contains previous command exit code
ls
$? = 0

We can set the exit status of script we running.
...
if [ some_command_failed ]
then 
  exit 1
fi
...

If we don't use exit in our script - last command exit code will be used for entire script.
Whenever exit command is reached in script - it stops running.
We can print "$?" even when script has run already, no matter when,
it allways keep status of previous command.

SEMICOLON
We can concatinate several commands with ";"
$>do_something ; do_something_else ; do_third ;
$? - exit status - will be the last exit status of command in sequence.
Everything will be executed no matter exit status.

FUNCTIONS
function name(){}
name(){}

name "some value"
Call function WITHOUT parentheses
All function should, include inner called should be declared before they are called.

Functions can have parameters $1 - first, $2 - second, $@ - all, like script params.
But not $0 - it's the shell script file itself.

By default all variables in script are global, so you can use them in functions if they were defined before function
call, so they can be defined after function definition, since they are global, but they should be defined before 
function called.

Variables defined in function became global after function run - and in most cases it's not good, so there is 
"local" keywork that we can use in functions only, to restricr inner variables became global. So that's the best way
is to declare function inner.
 
Functions has return code, allign with scripts. Two types:
 - Explicit: {... return 1}
 - Implicit: {... returns exit status of last runned command in function }
Difference with "exit 1" called in function - "exit" will exit script immediately, stop running it in current line,
"return" will just exit from function with status code, but not terminatesthe script running.
Rules of return codes - is the same for all other codes.

WILDCARDS
A character or string that used for pattern matching names of files, or directories.
Wildcards:
 * - 0 or more characters, matching anything, *.txt; a*; a*.txt;
 ? - 1 charachter, ?.txt; a?; a?.txt; 
 [charachter class] - matches any of the characters included in brackets, matches only 1 charachter.
    [aeiou] - any of the vowels (гласные) in name;
        ca[nt]* - can, cat, candy, catch.
    ! - NOT current pattern
        ca[!nt]* - any name started 'ca' but not followed by 'n', or 't'
    [a-g], [1-5] Range of charachters.
    Predifined name charachter classes
        [[:alpha:]] - lower and uppercase alphabetic character
        [[:alnum:]] - alphanumeric, means alphabetic character and digits
        [[:digit:]] - numbers in decimal [0-9]
        [[:lower:]] - lower alphabetic character
        [[:space:]] - whitespace
        [[:upper:]] - upper alphabetic character
    \ - escape wildcard symbol to use as a usual one
        question\?andAsterisk\*inName - "question?andAsterisk*inName" - name.

Pay attention on working  directory where are you running search, you should either cd to directory
from script, or set needed pass in script where you wanted to search files.


SWITCH CASE
Patterns are case sensetive.
Wildcards can be used as patterns, [asd]*.txt) command ;;

case $VARIABLE in
  pattern1)
    command_to_run1
    ;;
  pattern2)
    comand_to_run2
    ;;
esac

LOGGING
Who, what, where, when, why.

Linux syslog (system log) uses facilities and severities to categorize message.
Facilities: kern, user, nail, daemon. auth. local0, local7
Severities: emerg, alert, crit, err, warning, notice, info, debug
Each message labeled with facilitie code and severity level. For example messages with mail facilitie - comes from applications
that handeling mail. If you need to log them - you better use mail facilitie. If you not sure what facilitie to use - use 
user facilitie. local0 - local7 - custom logs.

Log files locations are configurable
/var/log/messages
/var/log/syslog

-p: logger -p local10.info "message" - add facilitie to your message;
-s: logger -s local10.info "message" - add severity to your message;
-t: logger -i -s my_shell_script -p local0.info "message" - tag your message tith script name, will be easily to search.
-i: logger -i -t script "Message" - add an PID (-i) to message.

WHILE LOOP
while [ condition ] or
ls | while read FILE or
while read LINE
do
  command N
  [ condition_to_exit ] && break #exit loop
  [ condition_to_continue ] && continue
done
done < /path_to_file/file # means read file, not working with txt on mac

Condition - variable value, command, etc.
You can redirect the contents of a file as input for a while loop 
as well as redirecting output of a command into a while loop using a pipe.